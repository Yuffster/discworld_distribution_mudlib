#/obj/handlers/autodoc/autodoc_file.c
public_functions (["set_no_join":({({"void",}),({}),(["main":({"This method stops this object joining with otherobjects when we encounter them.  A join will occur if we end up insame environment and the medium aliases match.",}),]),}),"query_weight_unit":({({"int","*",}),({}),(["main":({"This method returns the weight units used for this typeof unit.  The weight unit is an array ({ a, b }) which meansthat b units of stuff have weight a.",}),"return":({"the weight array",}),]),}),"adjust_amount":({({"void",}),({({"int",}),"number",}),(["main":({"This method changes the amount of stuff.",}),"param":({"number the amount to change it by",}),]),}),"query_max_seen":({({"int",}),({}),(["main":({"This method returns the maximum number of piles of theobject that can be seen.  Any more than this turns into 'many'.",}),"return":({"the maximum number of piles that can be seen",}),]),}),"query_parse_id":({({"object",}),({({"mixed","*",}),"args",}),([]),}),"query_value_scale":({({"float",}),({}),(["main":({"This method returns the current value scale.",}),"see":({"set_value_scale()","query_value()",}),"return":({"the value scale",}),]),}),"dest_old_env":({({"void",}),({({"object",}),"place",}),(["main":({"This method destructs the temporary container.",}),"param":({"place the object to destroy",}),]),}),"make_medium_clone":({({"object",}),({({"int",}),"number",}),(["main":({"This method makes a duplicate of ourselves at a different size.",}),"return":({"the new object",}),"param":({"number the new size of the object",}),]),}),"amount_size":({({"varargs","string",}),({({"int",}),"exact",}),(["main":({"This method returns a string which tells us how much stuff wehave.",}),"return":({"string representing the amount of stuff we have",}),]),}),"no_env_move":({({"void",}),({({"object",}),"dest",({"object",}),"place",}),(["main":({"This method checks to see if we are still in our silly little containerand if we are, moves us back.  We always dest the old container",}),"param":({"dest where we are going to","place the temporary container",}),]),}),"new_collective":({({"object",}),({({"int",}),"number",}),([]),}),"set_pile_types":({({"void",}),({({"mixed","*",}),"args",}),(["main":({"This method sets the name of the piles given the differentamounts of piles available.  The last pile type in the list isthe size to use for anything larger.  The pile sizes must be inorder.",}),"param":({"args the pile types",}),"example":({"set_pile_types(({ 50, \"small\", 100, \"medium\", 150, \"large\", \"huge\" }));",}),]),}),"reset_no_join":({({"void",}),({}),(["main":({"This method lets this object joining with otherobjects when we encounter them.  A join will occur if we end up insame environment and the medium aliases match.",}),]),}),"set_amount_types":({({"void",}),({({"mapping",}),"map",}),(["main":({"This method sets the sizes of the piles and their names.  Theargument is a mapping which contains the name of the pile andvalue is an array, the first element is the amount needed forthe name and the second element is the plural of the pile name.",}),"param":({"map the amount types mapping",}),"example":({"set_amount_types( ([ \"pinch\": ({ 1, \"pinches\" }),                 \"handful\": ({ 50, \"handfuls\" }) ]));",}),]),}),"query_how_many":({({"int",}),({}),(["main":({"This returns as an integer 'how many' we have of a particulartype.",}),"return":({"int representing the amount of a particular pile.",}),]),}),"query_pile_types":({({"mixed",}),({}),(["main":({"This method returns the array of pile types.The pile types array starts with a number, the number is thecut off amount to get the size name in the next array element.The numbers and strings alternate and the last element is thethe default size.",}),"return":({"the array of pile types",}),]),}),"query_collective":({({"int",}),({}),(["main":({"This method tests to see if this object is a collective or not.",}),"return":({"1 if it is continuous, 0 if not.",}),]),}),"query_no_join":({({"int",}),({}),(["main":({"This method checks to see if we are allowed to join with otherobjects when we encounter them.  A join will occur if we end up insame environment and the medium aliases match.",}),"return":({"1 if they cannot join, 0 if they can",}),]),}),"query_amount_types":({({"mapping",}),({}),(["main":({"This method returns the types of the different amounts.argument is a mapping which contains the name of the pile andvalue is an array, the first element is the amount needed forthe name and the second element is the plural of the pile name.",}),"return":({"the amount types mapping",}),]),}),"set_pile_name":({({"void",}),({({"string",}),"word",}),(["main":({"This method returns the name we give the piles of this stuff.",}),"param":({"word the name of the pile",}),"example":({"set_pile_name(\"puddle\");",}),]),}),"query_continuous":({({"int",}),({}),(["main":({"This method tests to see if this object is continuous or not.",}),"return":({"1 if it is continuous, 0 if not",}),]),}),"query_pile_name":({({"string",}),({}),(["main":({"This method returns the name we give the piles of this stuff.  Thisis the name given to piles of the object.",}),"return":({"the name of the pile",}),]),}),"query_amount":({({"int",}),({}),(["main":({"This method returns the amount of the stuff there is.  This is avolume measurement.",}),"return":({"the amount of stuff",}),]),}),"amount_size_short":({({"string",}),({}),(["main":({"This method returns a string which tells us how much stuff wehave.",}),"return":({"string representing the amount of stuff we have",}),]),}),"set_value_scale":({({"void",}),({({"float",}),"f",}),(["main":({"This method sets the amount by which to scale the value of acontinuous object.  If not set, the value will be that set withset_value().",}),"see":({"query_value_scale()","query_value()",}),"param":({"f the value scale",}),]),}),"query_value":({({"int",}),({}),(["main":({"This method returns the value of the object.  If the object isnot continuous, or the value_scale has not been set, the value isthe value set with set_value(), as usual.  Otherwise, the value isscaled by value_scale and multiplied by the current amount.",}),"see":({"set_value()","set_value_scale()","query_value_scale()",}),"return":({"the value of the object",}),]),}),"set_medium_alias":({({"void",}),({({"string",}),"word",}),(["main":({"This method sets the medium alias for the object.This should be a unique aliasfor the medium, it is used when joining to see if we can join or notIt it used for identification - choose something withcapitals (e.g. \"ChalkDust\") so players can'tuse it as a valid alias by accident.& @param word the medium alias",}),]),}),"reset_continuous":({({"void",}),({}),(["main":({"This method removes the continuous property from the object.",}),]),}),"query_merger":({({"int",}),({}),(["main":({"This method returns 1 if the object is available for mergin.",}),"return":({"1 if we can merge",}),]),}),"merge_criteria":({({"int",}),({({"object",}),"ob",}),([]),}),"query_medium_alias":({({"string",}),({}),(["main":({"This method returns the medium alias.  This should be a unique aliasfor the medium, it is used when joining to see if we can join or notIt it used for identification - choose something withcapitals (e.g. \"ChalkDust\") so players can'tuse it as a valid alias by accident.",}),"return":({"the medium alias",}),]),}),"set_collective":({({"void",}),({}),([]),}),"merge":({({"void",}),({}),([]),}),"pile_size":({({"string",}),({}),(["main":({"This method returns a string describing how big the pile is.",}),"return":({"the size of this pile of stuff",}),]),}),"set_weight_unit":({({"void",}),({({"int","*",}),"numbers",}),(["main":({"This method sets the weight units used for this typeof stuff.  The weight unit is an array ({ a, b }) which meansthat b units of stuff have weight a.",}),"param":({"numbers the new weight unit",}),]),}),"reset_collective":({({"void",}),({}),(["main":({"This method removes the collective property from the object.",}),]),}),"set_continuous":({({"void",}),({}),(["main":({"This method makes the object continuous.",}),]),}),"set_no_env_move":({({"void",}),({({"object",}),"dest",}),(["main":({"This method is for dealing with the object when bits are shaved off.If it is split up by someone referencing it we are moved into aspecial environment so we do not interfer with the old pile.  Theproperty \"medium dest\" will be used as the place to go, otherwisethe environment will be used.  This method sticks it into a specialon the fly created container.",}),"param":({"dest the place to move too  (this will be the \"medium dest\" orthe environment()",}),]),}),"set_amount":({({"void",}),({({"int",}),"number",}),(["main":({"This method sets the amount of the stuff there is.",}),"param":({"number the amount to set it to",}),]),}),])
protected_functions ([])
inherits (["/std/object":({}),])
main_docs (["main":({"Continuous Medium Object.amount: current quantity of medium in arbitrary unitscontinuous: 1 for continuous (default), reset to 0 for normal            object behaviourcollective: 1 for collective, 0 for normal behaviour.weight_unit: ({ a, b }) means that b units have weight avalue_scale (float): if set & continuous, value is ::query_value() * amount                     * value_scale; else value is ::query_value()medium_alias: used for identification - choose something with              capitals (e.g. \"ChalkDust\") so players can't              use it as a valid alias by accidentpile_name: \"pile\", \"collection\", \"puddle\", etc.amount_types: ([ \"pinch\": ({ 1, \"pinches\" }),                 \"handful\": ({ 50, \"handfuls\" }) ])pile_types: ({ 50, \"small\", 100, \"medium\", 150, \"large\", \"huge\" });Added by Jeremy, 4-Nov-95:ground, longs, shorts, medium_aliasesThe above were removed by Jeremy, 18-Jun-97.  Hopefully no one willmiss them.",}),"author":({"JeremyAdditions for collective objects:Since \"a\" and \"an\" will be replaced with the number of objects, \"$a\" and \"$an\" can be used if there should be a non-changing \"a\" or \"an\"in the long.For verbs you can use $V<singular-verb>$<plural-verb>. Example: $Vglows$glowIf there are any words which should be pluralized, place a $P in front of it,like $Pleaf or $PwordFinally you can use $A<word> if you want \"a word\" in for one object and\"words\" for more than one.",}),])
define_docs ([])
includes (["/include/obj_parser.h":1059516191,"/include/parse_command.h":1059516193,"/include/move_failures.h":1059516192,])
class_docs ([])
file_name "/obj/cont_medium.c"
last_changed 1059516270
