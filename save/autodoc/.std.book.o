#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_book":({({"int",}),({}),(["main":({"Tells us if this is a book object.",}),"return":({"always returns 1",}),]),}),"query_default_page_object":({({"string",}),({}),(["main":({"This method returns the default page object.",}),"return":({"the default page object (as a string)",}),]),}),"set_player":({({"void",}),({({"object",}),"player",}),(["main":({"This method is called by the auto loading process to set the currentplayer on this object.",}),"see":({"query_player()",}),"param":({"player the player to set",}),]),}),"query_book_num":({({"int",}),({}),(["main":({"This method returns the current number of the book.  This is assignedand used in conjunction with the book handler.",}),"see":({"/obj/handlers/book_handler.c","/std/print_shop.c",}),"return":({"the current book number",}),]),}),"set_default_page_object":({({"void",}),({({"string",}),"obj",}),(["main":({"Sets the object to use as the default page.  If this is not set thethe object /obj/misc/paper.c will be used.",}),"param":({"ob the object to use as the default page",}),]),}),"is_default_page":({({"int",}),({({"int",}),"num",}),(["main":({"This method checks to see if the page is still the default page objector if it is something else altogether.",}),"return":({"1 if it is the default page object, 0 if not",}),]),}),"add_page_after":({({"int",}),({({"object",}),"page",({"int",}),"after",}),(["main":({"This method adds a new page in after the selected page.  The pagesare numbered from 1, so adding a page after page 0 will place apage on the start and after the last page onto the end.",}),"see":({"query_current_page()","query_num_pages()",}),"return":({"1 on success, 0 on failure",}),"param":({"page the page to add","after the page to add it after",}),]),}),"create_default_page_object":({({"object",}),({}),(["main":({"This method creates a new default page object for this book.  THiscan be used for whatever nefarious purposes you want.",}),"return":({"a new default page object",}),]),}),"query_current_page_clone":({({"object",}),({}),(["main":({"This function makes sure the page actuallyexists.  If it does not exist, then it will clone oneup for us.  This one should be used as you will not end up with thebase object in this case.  If you are planning to modify the page,then use this call.",}),"see":({"query_current_page()",}),"return":({"the object of the current page",}),]),}),"tear_current_page_out":({({"object",}),({({"object",}),"dest",}),(["main":({"This method tears the current page out of the book and returns itto us.  This object will be moved into the destination so that it isno longer inside us.  If it cannot be moved of the page has alreadybeen remove then the function will return 0.",}),"return":({"the torn out page, or 0 on failure",}),"param":({"dest the destination to move the page to",}),]),}),"is_page_torn_out":({({"int",}),({({"int",}),"page",}),(["main":({"This method checks to see if the specified page is torn out.",}),"see":({"is_current_page_torn_out()",}),"return":({"1 if it is torn out, - if not",}),"param":({"page the page number to check",}),]),}),"query_selected_page_clone":({({"object",}),({({"int",}),"num",}),(["main":({"This method returns the contents of the selected page, if a defaultobject is returned a real clone for the page is created instead.",}),"return":({"0 on failure or if the page is torn out, the object on success",}),"param":({"num the page to return",}),]),}),"replace_page_with":({({"int",}),({({"object",}),"page",({"int",}),"num",}),(["main":({"This method replaces the selected page with a new page.  The old pageis dested if it can be and replaced with a nice shiny new page object.",}),"see":({"add_page_after()",}),"return":({"1 on success, 0 on failure",}),"param":({"page the page to replace with","num the page number to replace",}),]),}),"query_ignore_saved_pages":({({"int",}),({}),(["main":({"This method returns the current setting of the ignore savedpages variable.  If this is true thenthe pages form the players auto_load stuff will be ignored totalyand only the page creates in setup would beused.",}),"see":({"set_ignore_saved_pages()",}),"return":({"the current ignore saved page attribute",}),]),}),"query_open_page":({({"int",}),({}),(["main":({"What is the current open page.  Returns 0 if the book is notopen.",}),"see":({"set_open_page()","query_current_page()",}),"return":({"the current open page",}),]),}),"query_current_page":({({"object",}),({}),(["main":({"Returns the object associated with the current open page.  If thepage does not actualy exist yet then the default base objectis returned.  This object should be handled carefully...  If thepage is torn out then the next readable page is returned or0 is returned.",}),"see":({"query_current_page_clone()","set_open_page()","query_open_page()","query_current_page_clone()",}),"return":({"the current page object",}),]),}),"query_player":({({"object",}),({}),(["main":({"This method will return  the player associated with the auto loadingprocess.",}),"see":({"set_player()",}),"return":({"the player in use by the autoloading",}),]),}),"set_book_num":({({"void",}),({({"int",}),"num",}),(["main":({"This method sets the current number of the book.  This is assignedand used in conjunction with the book handler.",}),"see":({"/obj/handlers/book_handler.c","/std/print_shop.c",}),"param":({"num the new book number",}),]),}),"make_page_blank":({({"int",}),({({"int",}),"num",}),(["main":({"This method makes the selected page blank.  It defaults it back to adefault page object as if the book had just been created.",}),"see":({"replace_page_with()","add_page_after()","add_blank_page_after()",}),"param":({"num the page to make blank",}),]),}),"is_current_page_torn_out":({({"int",}),({}),(["main":({"This method checks to see if the current page is torn out.",}),"see":({"query_current_page()","query_open_page()","is_page_torn_out()",}),"return":({"1 if torn out, 0 if not",}),]),}),"query_selected_page":({({"object",}),({({"int",}),"num",}),(["main":({"This method returns the contents of the selected page.  The numbermust be greator than 0.  This will return the exact value of thepage, it will not search for non-torn out pages.  Becare withthe return value of this as the default page object might bereturned if the page does not actually exist.  If you need areal object remember to use the clone version.",}),"return":({"0 on failure or if the page is torn out, the object on success",}),"param":({"num the page to return",}),]),}),"set_open_page":({({"void",}),({({"int",}),"i",}),(["main":({"Sets the currently open page.  This does all the magic needed to makethe book appear as if it is the currently opened page.  If the openpage is 0 then the book is closed.  If it is out of the upperbound then the book is opened to the last page.",}),"see":({"query_open_page()","query_current_page()",}),"param":({"i the page to open to",}),]),}),"query_pages":({({"mixed","*",}),({}),(["main":({"Returns the pages array.",}),"return":({"the array containing the pages information",}),]),}),"query_num_pages":({({"int",}),({}),(["main":({"Queries the number of pages in the book.",}),"see":({"set_no_pages()",}),"return":({"the number of pages in the book",}),]),}),"set_no_pages":({({"void",}),({({"int",}),"no",}),(["main":({"Set the number of pages in the book.  If there are too many pagesin the book, then pages are removed from the top to create thecorrect size and if there are too few pages then pages areadded onto the end of the pages array.",}),"see":({"query_pages()","query_num_pages()",}),"param":({"no the number of pages",}),]),}),])
protected_functions (["set_ignore_saved_pages":({({"void",}),({({"int",}),"saved",}),(["main":({"This method sets the current setting of the ignore savedpages variable.  If this is true thenthe pages form the players auto_load stuff will be ignored totalyand only the page creates in setup would beused.  This can only be called from an objectwhich inherits this one (hence the protected method).",}),"see":({"query_ignore_saved_pages()",}),"param":({"saved the new value of the saved attribute",}),]),}),])
inherits (["/std/object":({}),])
main_docs (["main":({"A nice book object.  A book will be a collection of pages.You can tear pages out of a book, you can add pages (though addinga page isnt overly useful, unless you bind it in of course).<p>Each page is an object.  Pages that are torn out are handledas empty spots in the array.<p>",}),"author":({"Pinkfish",}),"change":({"26-Feb-96 JeremyI took out the \"my book\" checks in test_add() and test_remove()because they were keeping written pages from loading.  Ifanyone knows why the checks were necessary, let me know.","25-Aug-96 JeremyChanged test_add() so that it won't add things held by players.This is because if they \"put\" something in the book, it's inaccessible(maybe this is why pages had the \"my book\" property?  I like thissolution better, but not much).",}),])
define_docs ([])
includes (["/include/move_failures.h":1059516192,"/include/player.h":1059516192,"/include/playtesters.h":1059516192,])
class_docs ([])
file_name "/std/book.c"
last_changed 1059516249
