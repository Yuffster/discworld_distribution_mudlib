#/obj/handlers/autodoc/autodoc_file.c
public_functions (["do_spell_action":({({"void",}),({({"object",}),"caster",({"object","*",}),"targets",({"mixed",}),"action",({"mixed",}),"args",}),(["main":({"This method does a combat action.",}),"param":({"caster the caster of the spell","targets the targets of the spell","action the action to do","args the spell arguements",}),]),}),"queue_command":({({"varargs","int",}),({({"string",}),"words",({"int",}),"interval",}),(["see":({"delay_command()","query_queued_commands()","init_command()","do_command()",}),"main":({"This method allows you to control the npc and get it to doactions where they are queued as for players.  If there are nocommands pending the command is executed immediately.  This functionis 100% compatible with delay_command() and init_command().",}),"param":({"words the action to perform","interval to wait before processing another command.If omitted defaults to 2 seconds as per players",}),"example":({"ob = clone_object(NICE_HAIRY_APE);ob->queue_command(\"'I am a hairy ape!\");ob->queue_command(\"emote apes around the room.\",5);ob->queue_command(\"get banana\",10);ob->delay_command(\"emote get apple.\",3);Right away it says \"I am a hairy ape\",2 seconds later it apes around the room,5 seconds after that it gets a bananaand 13 seconds (10+3) after that it gets an apple.",}),]),}),"query_spell_actions":({({"mapping",}),({}),(["main":({"This method returns the list of spell actions present on thenpc.",}),"return":({"the list of spell actions",}),]),}),"remove_spell_action":({({"int",}),({({"string",}),"name",}),(["main":({"This method removes the specified spell action.",}),"return":({"1 if successful, 0 if not",}),"param":({"name the name of the spell to remove",}),]),}),"query_ok_turn_off_heart_beat":({({"int",}),({}),(["main":({"This method returns 1 if it is ok to turn of the npc's heart beat.THis can be overridden for times when the heart beat needs to bekept on for some reason.",}),"return":({"1 if the heart beat should go off, 0 if it should stay on",}),]),}),"delay_command":({({"int",}),({({"string",}),"words",({"int",}),"interval",}),(["see":({"queue_command()","query_queued_commands()","init_command()","do_command()",}),"main":({"This method allows you to control the npc and get it to doactions where they are queued as for players.   The commandis always delayed by delay even if there are no commands pendingunlike queue_command(). This functionis 100% compatible with queue_command() and init_command().",}),"param":({"words the action to perform","interval to wait before the command.",}),"example":({"ob = clone_object(NICE_HAIRY_APE);ob->delay_command(\"'I am a hairy ape!\",10);ob->delay_command(\"emote apes around the room.\",2);ob->queue_command(\"emote get banana.\",3);ob->queue_command(\"emote get apple.\");After 10 seconds it says \"I am a hariy ape\",2 seconds after that it apes around the room,immediately following that it gets a bananaand 3 seconds after that it gets an apple.",}),]),}),"add_spell_action":({({"void",}),({({"string",}),"spell_object",({"int",}),"chance",({"string",}),"name",({"mixed",}),"action",}),(["main":({"This method adds an action to the npc that will happen if a specifiedspell is cast.  This is an action whichhas a chance of occuring when a spell is being cast.The name is an identifierwhich can be used to remove the action with later.  The actionitself can be a string, then that command will be executed.  Ifthe action is a function pointer then it will be evaluated withtwo arguments, the first being the caster, the second being thetarget(s) array and the third being the magic arguments class.<p>If the action is an array, if it is one element then the functionspecified will be called on the attacked with the same arguementsas above.  If the size of the array is two then the function willbe called on the specified object with an extra first argument beingthe npc which the effect is being called from.",}),"param":({"spell_object the spell to respond to","chance the chance of it working","name the name of the thing","action the action to preform",}),]),}),"combat_actions_call_back":({({"void",}),({({"object",}),"player",({"object",}),"target",}),(["main":({"This is the call back from the combat effect to do somethingwonderful and wild.",}),"param":({"player the player","target the target",}),]),}),"expand_mon_string":({({"void",}),({({"mixed",}),"str",}),(["see":({"expand_string()",}),"main":({"This method executes the string passed in.  It handles all thestuff which is needed from the chat_string stuff.If the input is a function pointer then it is evaluated with oneparameter, being the npc.If the input is a string then the first letter determines what willbe done with it.  All these are passed through expand_stringso that exciting things can be done.<ul><li># - A call_other will be generated.  The parameters are separated by':'s, so \"#frog:bing:fred:chicken\" would call<pre>this_object()->bing(\"fred\", \"chicken\");</pre>.<ul>', \", : - These will generate a 'say', 'lsay' or 'emote'.<ul>@ - This will run the passed in command.  Eg: \"@frog\" would cause the    soul command frog to be used.<ul>Anything else will be used as a message to be sent to everyone in the    room.</ul>",}),"param":({"str the thing to execute",}),]),}),"do_combat_action":({({"void",}),({({"object",}),"player",({"object",}),"target",({"mixed",}),"action",}),(["main":({"This method does a combat action.",}),"param":({"target the target of the action","thing",}),]),}),"delete_queued_commands":({({"void",}),({}),(["see":({"init_equip()","init_command()","delay_command()","do_command()","queue_command()",}),"main":({"This method throws away any queued commands.It doesn't remove the call_out however if nonew commands are added there will be no effect.",}),]),}),"query_combat_actions":({({"mixed","*",}),({}),(["see":({"add_combat_action()","remove_combat_actions()","/std/effects/fighting/combat.c",}),"main":({"This method returns the current array of combat actions on thenpc.<p>The array will have the format of:<pre>   ({       action1_chance,       action1_name,       action1_action,       ...    })</pre>",}),"return":({"the combat action array",}),]),}),"event_npc_ritual_casting":({({"void",}),({({"object",}),"ritual",({"object",}),"caster",({"object","*",}),"targets",({"class","spell_argument",}),"args",}),(["main":({"This is the event called when a ritual is being cast.",}),"param":({"spell_ob the ritual","caster the caster of the ritual","targets the targets of the ritual","args the ritual arguements",}),]),}),"reset_enter_commands":({({"void",}),({}),(["see":({"add_enter_commands()","add_enter_commands()",}),"main":({"This method resets the array of enter commands back to nothing.",}),]),}),"remove_combat_action":({({"int",}),({({"string",}),"name",}),(["see":({"add_combat_action()","query_combat_actions()","/std/effects/fighting/combat.c",}),"main":({"This method will remove the combat action with the specified name.",}),"return":({"1 if it is found and removed, 0 if not",}),]),}),"query_race_ob":({({"mixed",}),({}),(["see":({"set_race()","set_race_ob()","set_level()",}),"main":({"This returns the race object associated with the npc.",}),"return":({"the race object associated with the npc",}),]),}),"do_command":({({"int",}),({({"string",}),"words",}),(["see":({"init_equip()","init_command()",}),"main":({"This method allows you to control the npc and get it to doactions.  This can be used for npc control and inteligence.Be very careful with this command! This does not go through anycommand queue like players have and so NPCs can end up doingtons of commands in very short order.If you're trying to make your NPC act like a player useeue_command() instead",}),"param":({"words the action to preform",}),"example":({"ob = clone_object(NICE_HAIRY_APE);ob->do_command(\"'I am a hairy ape!\");ob->do_command(\"emote apes around the room.\");",}),]),}),"query_enter_commands":({({"string","*",}),({}),(["see":({"reset_enter_commands()","add_enter_commands()",}),"main":({"This method returns the current array of enter commands.",}),"return":({"the current array of enter commands",}),]),}),"add_combat_action":({({"void",}),({({"int",}),"chance",({"string",}),"name",({"mixed",}),"action",}),(["see":({"remove_combat_action()","query_combat_actions()","/std/effects/fighting/combat.c",}),"main":({"This method adds a combat action to the npc.  This is an action whichhas a chance of occuring during combat.  The name is an identifierwhich can be used to remove the action with later.  The actionitself can be a string, then that command will be executed.  Ifthe action is a function pointer then it will be evaluated withtwo arguments, the first being the attacker, the second being thetarget.<p>If the action is an array, if it is one element then the functionspecified will be called on the attacked with the same arguementsas above.  If the size of the array is two then the function willbe called on the specified object with the arguments as above.",}),]),}),"move_me_to":({({"varargs","void",}),({({"string",}),"dest",({"int",}),"delay",}),(["see":({"get_next_route_direction()","got_the_route()","query_last_route_direction()","query_following_route()","do_route_move()",}),"main":({"This method will move the npc to the specified destination.  Thenpc will walk from where they currently are to the destination usingthe time delay specified between the movements.<p>If the location is reached then the function \"stopped_route\" willbe called on the npc.  The first arguement to the function willbe 0 if the npc did not reach its destination and 1 if it did.",}),"param":({"dest the destination to go to","delay the time delay between each move",}),"example":({"inherit \"/obj/monster\";void go_home() {   move_me_to(HOME_LOCATION, 2);} /* go_home() */void stopped_route(int success) {   if (success) {      do_command(\"emote jumps for joy.\");   } else {      do_command(\"emote looks sad and lost.\");   }} /* stopped_route() */",}),]),}),"add_enter_commands":({({"int",}),({({"mixed",}),"str",}),(["see":({"reset_enter_commands()","query_enter_commands()",}),"main":({"This method adds a command to be called whenever the npc entersa room.  If the command is a string, then it will be executedas if they had typed it.  If it is a function then the functionwill be evaluated and one argument (the npc itself) will be passedin.",}),"param":({"str the enter commands to add",}),]),}),"set_aggressive":({({"void",}),({({"int",}),"a",}),(["see":({"query_aggressive()","start_attack()","set_join_fights()","set_throw_out()",}),"main":({"This method sets the current aggressive level of the npc.If the aggressive is set to 1, then the npc will attack all playersthat enter its environment.  If the aggressive is set to 2 thenthe npc will attack everything (including other npcs).<p>See the function start_attack() for information about things youcan do to stop aggressive npcs attacking things.",}),"param":({"a the new aggressive level",}),]),}),"expand_string":({({"string",}),({({"string",}),"in_str",({"object",}),"on",}),(["see":({"set_chat_string()","expand_mon_string()",}),"main":({"This method is used to expand the message strings used in thenpc messages.  It is used for chat strings and such things likethat.  The strings it expands are of the form:<br>$lname$, $mname$, $aname$, ...<br>The first letter determines the type of object being referenced.They are:<dl><dt>m<dd>Me!  The npc itself.<dt>l<dt>A living object, choose a random living object in the npcs    environment.<dt>a<dd> Chooses a random attacker from those attacking the npc.<dt>o<dd>Choose a random object in the inventory of the npc.</dl>After the first letter is a type of information being request.<dl><dt>name<dd>The name of the selected object.<dt>cname<dd>The capitalised name of the selected object.<dt>gender<dd>The gender string of the selected object (male, female, neuter).<dt>poss<dd>The possessive string of the selected object.<dt>obj<dd>The objective string of the selected object.<dt>pronoun<dd>The pronoun string of the selected object.<dt>gtitle<dd>The guild title of the selected object (only useful on livings).<dt>ashort<dd>The a_short() call.<dt>possshort<dd>The poss_short() call.<dt>theshort<dd>The the_short() call.<dt>oneshort<dd>The one_short() call.</dl>",}),"param":({"in_str the input string","on the object to use for the 'o' matching",}),]),}),"query_dynamic_auto_load":({({"mapping",}),({}),([]),}),"do_follow_move":({({"void",}),({({"string",}),"dir",}),(["main":({"This method is used to make the npcs follow after attackers when theyleave the room.",}),"param":({"dir the dirction to follow them in",}),]),}),"query_move_after":({({"mixed",}),({}),(["see":({"set_move_after()",}),"main":({"This method returns the current move after values.It returns an array of the form:<pre>   ({     after,     rand,    })</pre>",}),"return":({"the move after values",}),]),}),"set_follow_speed":({({"void",}),({({"int",}),"f",}),(["see":({"set_follow_speed()",}),"main":({"This method sets the speed at which the npc will followafter a player when they leave combat.",}),"return":({"the current follow speed",}),]),}),"init_dynamic_arg":({({"void",}),({({"mapping",}),"args",({"object",}),"ob",}),([]),}),"query_fight_type":({({"int",}),({}),(["see":({"set_join_fights()","query_join_fight_type()",}),"main":({"This method returns the flag which allows the npc to join into fights.",}),"return":({"1 if the npc is to join fights, 0 if not",}),]),}),"query_throw_out":({({"mixed","*",}),({}),(["see":({"set_throw_out()",}),"main":({"This method returns the current throw out array.The array consists of<pre>({  hps,  chance,  their_mess,  everyone_mess})</pre>The parameters are the same as used in the set_throw_outfunction.",}),"return":({"the throw out array",}),]),}),"query_move_zones":({({"string","*",}),({}),(["see":({"add_move_zone()","remove_move_zones()","set_move_after()",}),"main":({"This method returns the current list of move zones on the npc",}),"return":({"the current list of move zones",}),]),}),"query_queued_commands":({({"mixed","*",}),({}),(["see":({"init_equip()","init_command()","delay_command()","do_command()","queue_command()",}),"main":({"This method returns the queued command list.",}),]),}),"set_join_fights":({({"void",}),({({"string",}),"str",}),(["see":({"query_join_fights()","set_join_fight_type()",}),"main":({"This method sets the message to use when joining into fights.",}),"param":({"str the message to print when joining a fight",}),]),}),"remove_move_zone":({({"void",}),({({"mixed",}),"zone",}),(["see":({"add_move_zone()","query_move_zones()","set_move_after()",}),"main":({"This method removes a move zone from the npc.",}),"param":({"zone the zone to remove",}),]),}),"set_join_fight_type":({({"void",}),({({"int",}),"i",}),(["see":({"set_join_fights()","query_join_fight_type()",}),"main":({"This method sets the flag which allows the npc to join into fights.If this is set to a non-zero value then the npc will join intofights in progress using the fight joining message.",}),"param":({"i 1 if the npc is to join fights, 0 if not",}),]),}),"query_following_route":({({"string","*",}),({}),(["see":({"get_next_route_direction()","query_last_route_direction()","do_route_move()",}),"main":({"This method returns the current array of directions we are followingas a route.",}),]),}),"query_guild":({({"string",}),({}),(["see":({"query_race()","set_guild()","set_level()",}),"main":({"This method returns the current guild of the npc.",}),"return":({"this current guild of the npc",}),]),}),"query_join_fights":({({"string",}),({}),(["see":({"set_join_fights()","set_join_fight_type()",}),"main":({"This method returns the message to use when joining into fights.",}),"return":({"the message to print when joining a fight",}),]),}),"query_last_route_direction":({({"int",}),({}),(["see":({"get_next_route_direction()","query_following_route()","do_route_move()",}),"main":({"This method tells us if the npc is currently following a route.",}),"return":({"1 if there are route directions to follow still",}),]),}),"set_achat_chance":({({"void",}),({({"int",}),"i",}),(["see":({"load_chat()","load_achat()","query_achat_chance()",}),"main":({"This method sets the current chat chance for attack messages on thenpc.",}),"param":({"i the attack message chat chance",}),]),}),"drunk_check":({({"int",}),({({"string",}),"str",}),([]),}),"remove_achat_string":({({"void",}),({({"mixed",}),"chat",}),(["see":({"add_achat_string()","load_chat()","load_achat()",}),"main":({"This method attempts to remove the given chat string from thecurrent list of attack message chat strings.  The chat message is checkedto see if it exists in the array, the weighting of thestring is ignored.",}),"param":({"chat the chat string to remove",}),]),}),"get_next_route_direction":({({"string",}),({}),(["see":({"query_last_route_direction()","query_following_route()","do_route_move()",}),"main":({"This method gets the next direction to go in the route which iscurrently being followed.  It will remove this direction off thearray.",}),"return":({"the next direction to go down",}),]),}),"add_achat_string":({({"void",}),({({"mixed",}),"weight",({"mixed",}),"chat",}),(["see":({"load_chat()","load_achat()","remove_achat_string()",}),"main":({"This method adds a single chat string into the current list ofattack message chat strings.  See load_chat() for a longer description ofthe chat string.",}),"param":({"weight the weight of the chat","chat the new chat string",}),]),}),"event_fight_in_progress":({({"void",}),({({"object",}),"me",({"object",}),"him",}),(["main":({"This event is called when a fight is in progress.  It willbe used for things like joining into currently runningfights and initiating combat with spell casters.",}),"param":({"me the person initiating the attack","him the person being attacked",}),]),}),"query_death_xp":({({"int",}),({}),(["main":({"This method returns the amount of death experiecne that would begained by killing the npc.",}),"return":({"the amount of death experience for the npc",}),]),}),"start_attack":({({"void",}),({({"object",}),"who",}),(["see":({"set_aggressive()",}),"main":({"This method check to see if the npc should start attacking someonewhen they enter the npcs environment.  It is called from insideinit().  It will only attack if the agressive is set and theperson is visible to be attacked.  The property<pre>\"no attack\"</pre> can be set on the npc (or player) tostop them being attacked.",}),"param":({"who the person to potentially start attacking",}),]),}),"set_chat_chance":({({"void",}),({({"int",}),"i",}),(["see":({"load_chat()","query_chat_chance()",}),"main":({"This method sets the current chat chance for messages on thenpc.",}),"param":({"i the chat chance",}),]),}),"query_achat_string":({({"string","*",}),({}),(["see":({"load_chat()","load_achat()","set_chat_string()",}),"main":({"This method queries the current chat string for attack messages on thenpc.  See load_chat() for a longer description of how thechat string is formatted.",}),"return":({"the current attack message chat string",}),]),}),"do_move":({({"void",}),({({"string",}),"move",}),(["main":({"This method causes the npc to move in the given direction.",}),"param":({"move the direction to move",}),]),}),"add_chat_string":({({"void",}),({({"mixed",}),"weight",({"mixed",}),"chat",}),(["see":({"load_chat()","remove_chat_string()",}),"main":({"This method adds a single chat string into the current list ofchat strings.  See load_chat() for a longer description ofthe chat string.",}),"param":({"weight the weight of the chat","chat the new chat string",}),]),}),"set_achat_string":({({"void",}),({({"string","*",}),"chat",}),(["see":({"load_chat()","load_achat()","query_achat_string()",}),"main":({"This method sets the current chat string for attack messages on thenpc.  See load_chat() for a longer description of how thechat string is formatted.",}),"param":({"chat the new chat attack message strings.",}),]),}),"do_route_move":({({"void",}),({}),(["see":({"query_last_route_direction()","query_following_route()","get_next_route_direction()",}),"main":({"This method moves the npc one more location along the route itis following.",}),]),}),"do_move_after":({({"void",}),({({"int",}),"running_away",}),(["see":({"set_move_after()",}),"main":({"This is called when the npc decides it must continue downa certain route.  This will be called by the wander handlerand can be used to force the npc to wander along a routefaster.",}),"param":({"running_away this is 1 if the npc is running away",}),]),}),"query_guild_ob":({({"mixed",}),({}),(["see":({"set_guild()","set_guild_ob()","set_level()",}),"main":({"This returns the guild object associated with the npc.",}),"return":({"the guild object associated with the npc",}),]),}),"cleaning_room":({({"int",}),({}),([]),}),"give_money":({({"int",}),({({"int",}),"base",({"int",}),"rand",({"string",}),"type",}),(["see":({"/std/living/money.c",}),"main":({"This method is used to give some startup money to the npc.",}),"return":({"the return value of adjust_money()",}),"param":({"base the base amount of money to give (fixed)","rand the random amount of money to give","type the type of money to give (default: \"copper\")",}),"example":({"ob = clone_object(CLUCKY_CHICKEN);// This will give the chicken 10 + random(10) royals.// It is a royal chickenob->give_money(10, 10, \"royal\");",}),]),}),"query_achat_chance":({({"int",}),({}),(["see":({"set_achat_chance()","load_chat()","load_achat()",}),"main":({"This method returns the current chat chance for attack messages onthe npc.",}),"return":({"the current attack message chat chance",}),]),}),"query_always_return_to_default_position":({({"int",}),({}),(["see":({"/std/living/living->return_to_default_position()","set_always_return_to_default_position()",}),"main":({"This method returns the status of the flag that makes the npc returnto the default position if its position is changed.  The flagspecified the length of time to wait before causing thedefault position to be restored.",}),"return":({"the time to wait before the position is restored",}),]),}),"set_true_location":({({"void",}),({({"string",}),"word",}),(["see":({"set_true_location()","set_virtual_move()",}),"main":({"This method sets the true location of the npc.  This isthe real room it is in, not the room it is currently in.",}),"param":({"word the new true location of the npc",}),]),}),"set_guild_ob":({({"void",}),({({"mixed",}),"g",}),(["see":({"set_level()","set_guild()","/std/race.c",}),"main":({"This method sets the guild object associated with the npc.This will probably not do what you expect and cannot be usedin conjucton with set_level to set the guild.  It is calledby /std/race.c when set_level() is called.",}),"param":({"g the new guild object",}),]),}),"set_random_stats":({({"void",}),({({"int",}),"no",({"int",}),"type",}),(["see":({"rand_num()",}),"main":({"This method sets the stats for the npc to some exciting randomvalues.",}),"param":({"no the number of times to roll the dice","type the size of the dice",}),]),}),"set_race_ob":({({"void",}),({({"mixed",}),"r",}),(["see":({"set_level()","set_race()","/std/race.c",}),"main":({"This method sets the race object associated with the npc.This will probably not do what you expect and cannot be usedin conjucton with set_level to set the race.  It is calledby /std/race.c when set_level() is called.",}),"param":({"r the new race object",}),]),}),"query_level":({({"int",}),({}),(["see":({"set_guild()",}),"main":({"This method returns the current guild level of the npc.  This isa pass through call to a function on the guild object associatedwith this npc.",}),"return":({"the current guild level of the object",}),]),}),"set_cap_name":({({"void",}),({({"string",}),"s",}),(["see":({"query_cap_name()",}),"main":({"This method set the current capitalized name of the npc.",}),"param":({"s the capitalized name of the npc",}),]),}),"load_a_chat":({({"void",}),({({"int",}),"chance",({"mixed","*",}),"c_s",}),(["see":({"load_chat()","query_achat_chance()","query_achat_string()",}),"main":({"This method loads up the set of chat strings to use while in combat.",}),"param":({"chance the chance of the chat occuring","c_s the chat string to use",}),]),}),"query_true_location":({({"string",}),({}),(["see":({"set_true_location()","set_virtual_move()",}),"main":({"This method returns the true location of the npc.  This isthe real room it is in, not the room it is currently in.",}),"return":({"the true location of the npc",}),]),}),"real_room":({({"void",}),({({"string",}),"check_room",}),(["see":({"query_virtual_move()",}),"main":({"This method moves the npc to room it is really supposed to be in.This is used with the virtual moving",}),"param":({"check_room the place where it thinks we are",}),]),}),"set_always_return_to_default_position":({({"void",}),({({"int",}),"tim",}),(["see":({"/std/living/living->return_to_default_position()","query_always_return_to_default_position()",}),"main":({"This method sets the status of the flag that makes the npc returnto the default position if its position is changed.  The flagspecified the length of time to wait before causing thedefault position to be restored.",}),"param":({"tim the time to wait before the position is restored",}),]),}),"set_virtual_move":({({"void",}),({({"int",}),"number",}),(["see":({"query_virtual_move()",}),"main":({"This method sets the current virual move ability of the npc.NB: This is currently disabled virtual moving is not possibleat all.",}),"param":({"number 1 for virtual moving, 0 for not",}),]),}),"remove_chat_string":({({"void",}),({({"mixed",}),"chat",}),(["see":({"add_chat_string()","load_chat()",}),"main":({"This method attempts to remove the given chat string from thecurrent list of chat strings.  The chat message is checkedto see if it exists in the array, the weighting of thestring is ignored.",}),"param":({"chat the chat string to remove",}),]),}),"init_static_arg":({({"void",}),({({"mapping",}),"args",}),([]),}),"query_virtual_move":({({"int",}),({}),([]),}),"init_equip":({({"void",}),({}),(["see":({"do_command()",}),"main":({"This method makes the npc initialise all their equipment, like holdit and stuff.",}),]),}),"query_cannot_change_position":({({"int",}),({}),(["see":({"/std/living/living->set_default_position()",}),"main":({"This method returns the current value of the unable to changeposition flag.",}),"return":({"the unable to change position flag",}),]),}),"query_chat_string":({({"string","*",}),({}),(["see":({"load_chat()","query_chat_string()",}),"main":({"This method queries the current chat string for messages on thenpc.  See load_chat() for a longer description of how thechat string is formatted.",}),"return":({"the current chat string",}),]),}),"command_override":({({"void",}),({({"function",}),"func",}),(["main":({"Use this function to set a function that is called with the NPCs inputbefore command() gets it, return 1 from the function if theinput needs no further parsing (ie the command is handled)",}),"param":({"func = function in the players environment to call.",}),]),}),"run_away":({({"int",}),({}),(["main":({"This method is used to make the npc run away.  This will becalled by the combat code for wimpy when the npc is bellow thenumber of points used to trigger the wimpy action.",}),"return":({"1 if successfuly ran away",}),]),}),"set_chat_string":({({"void",}),({({"string","*",}),"chat",}),(["see":({"load_chat()","query_chat_string()",}),"main":({"This method sets the current chat string for messages on thenpc.  See load_chat() for a longer description of how thechat string is formatted.",}),"param":({"chat the new chat strings.",}),]),}),"check_anyone_here":({({"int",}),({}),(["main":({"This method checks to see if there are any players in the environmentof the npc.  This should be used to determine when chats shouldbe turned off and other things which should only work in thepresence of players.",}),"return":({"1 if there is a player in the room, 0 otherwise",}),]),}),"set_level":({({"void",}),({({"int",}),"i",}),(["see":({"set_race()","set_guild()","basic_setup()",}),"main":({"This function is deprecated.  Use basic_setup() instead.This method sets the level of the npc.  This should only be called*after* the race and guild are set.  If this is called before thatthe results will be unexpected.",}),"param":({"i the level to set the npc to",}),]),}),"set_cannot_change_position":({({"void",}),({({"int",}),"flag",}),(["see":({"/std/living/living->set_default_position()",}),"main":({"This method sets the value of the unable to change position flag.This flag will be checked by the soul, and by anything else whichdeliberatly changes someones position.",}),"param":({"flag the unable to change position flag",}),]),}),"query_chat_chance":({({"int",}),({}),(["see":({"set_chat_chance()","load_chat()",}),"main":({"This method returns the current chat chance for messages onthe npc",}),"return":({"the current chat chance",}),]),}),"event_npc_spell_casting":({({"void",}),({({"object",}),"spell",({"object",}),"caster",({"object","*",}),"targets",({"class","spell_argument",}),"args",}),(["main":({"This is the event called when a spell is being cast.",}),"param":({"spell_ob the spell object","caster the caster of the spell","targets the targets of the spell","args the spell arguements",}),]),}),"set_guild":({({"int",}),({({"string",}),"str",}),(["see":({"query_race()","query_guild()","set_guild()","set_level()",}),"main":({"This method is deprecated.  Use basic_setup() instead.This method sets the current guild of the npc to thepassed in value.  The guild should be one ofthe guilds listed in the /std/race.c object.This is used in conjuction with therace when set_level is called to setup the defaultattributes for the npc.  This should only becalled *before* set_level() is called.",}),"param":({"str the new guild for the npc",}),"example":({"ob = clone_object(\"/obj/monster\");ob->set_guild(\"fighter\");","inherit \"/obj/monster\";void setup() {   ...   set_race(\"fighter\");   ...   set_level(12);} /* setup() */",}),]),}),"load_chat":({({"void",}),({({"int",}),"chance",({"mixed","*",}),"c_s",}),(["see":({"expand_mon_string()","load_a_chat()","query_chat_chance()","query_chat_string()",}),"main":({"This method loads up the chat strings for the npc.  This will bean array containing pairs of elements, the first pair is theweighting of the chat and the second is the chat to use.<p>All the weights in the array are added up and then a randomnumber is chosen in the weighting.  Then that element is lookedup in the array.  This way you can control a chat and make itrare.<p>If the chat string is an array then this a story, the story will beexecuted one after another and no other chats will be executedin between.  If the first parameter of the story array is a number itwill be used as a 1/1000 chance of the next story line being displayed. Special strings can be used which will replace withobject names, see expand_mon_string() for further information.<p>The chat chance is a chance (in 1000) of the chat occuring.  Youwill need to play with this yourself to see which frequency ofchatting you wish for your npcs.",}),"param":({"chance the chance in 1000 of a chat working every 2 seconds","c_s the chat string to use",}),"example":({"load_chat(60,   ({      1, \"'I am a chicken!\",      // Make this one more likely to occur.      2, \":clucks like a chicken.\"      1, \":pecks at $lpossshort$ foot.\"    }));","load_chat(100,   ({      1, \"'I am a simple farmer.\"      1, \":waves $mposs$ pitchfork around.\"      // A story, they will always occur in this order      1, ({          500,           \"'Once upon a time there was a rabbit.\",           \"'It was a nice rabbit and hung around in bars.\",           \"'It sung little songs about fruit.\",          }),     }));",}),]),}),"set_race":({({"int",}),({({"string",}),"str",}),(["see":({"query_race()","query_guild()","set_guild()","set_level()","basic_setup()",}),"main":({"This function is deprecated.  Use basic_setup() instead.This method sets the race of the npc.  The race should be one ofthe races listed in the /std/race.c object.This is used in conjuction with theguild when set_level is called to setup the defaultattributes for the npc.  This should only becalled *before* set_level() is called.",}),"return":({"always returns 1",}),"param":({"str the race to set",}),"example":({"ob = clone_object(\"/obj/monster\");ob->set_race(\"fish\");","inherit \"/obj/monster\";void setup() {   ...   set_race(\"fish\");   ...   set_level(12);} /* setup() */",}),]),}),"add_move_zone":({({"void",}),({({"mixed",}),"zone",}),(["see":({"remove_move_zone()","query_move_zones()","set_move_after()",}),"main":({"This method adds a move zone onto the npc.  The move zones controlwhich areas the npcs will wander into, a move zone is set on theroom and the npcs will only enter rooms which have a matchingmove zone.  If there is no move zone, then the npc will enterany room.<p>If the parameter is an array each of the elements of the arraywill be added as a move zone.",}),"param":({"zone the zone(s) to add",}),]),}),"set_move_after":({({"void",}),({({"int",}),"after",({"int",}),"rand",}),(["see":({"remove_move_zone()","query_move_zones()","add_move_zone()",}),"main":({"This method sets the speed at which the npc will randomlywander around.  The npc will wander at the speed:<pre>speed = after + random(rand)</pre>This is called every time the npc sets up for its next move.<p>The move zones controlwhich areas the npcs will wander into, a move zone is set on theroom and the npcs will only enter rooms which have a matchingmove zone.  If there is no move zone, then the npc will enterany room.",}),"param":({"after the fixed amount of time","rand the random amount of time",}),]),}),"query_cap_name":({({"string",}),({}),(["see":({"set_cap_name()",}),"main":({"This method returns the current capitalized name of the npc.",}),"return":({"the current capitalized name",}),]),}),"attack_permission":({({"int",}),({({"object",}),"ob1",({"object",}),"ob2",({"string",}),"stringy",}),(["see":({"efun::allow_attack()",}),"main":({"attack_permission function, added for use by the allow_attack simul.",}),"return":({"int 1 if the action is denied, 0 is it can go through.",}),"param":({"object The person performing the action","object The object being acted on, this object usually.","string Attack type, this will be one of \"combat\", \"theft\", or \"magic\",this lets you give your NPCs different responses for different attacks. As wellas make them immune to theft and magic (as an example)",}),]),}),"init_command":({({"varargs","void",}),({({"string",}),"str",({"int",}),"tim",}),(["see":({"do_command()","queue_command()","delay_command()",}),"main":({"This method allows you submit delayed commands to the npcvia a call_out.",}),]),}),"setup_nationality":({({"void",}),({({"string",}),"nationality",({"string",}),"region",}),(["main":({"This method sets up a nationality and sets up a region in thenationality for the npc.",}),"param":({"nationality the nationality to set","region the region in the nationality",}),]),}),"basic_setup":({({"void",}),({({"string",}),"race",({"string",}),"guild",({"int",}),"level",}),(["see":({"set_race()","set_guild()","set_level()",}),"main":({"This method sets up the basic abilities and race of the critter.  Itis equivalent to calling set_race(), set_guild(), and then set_level()with the same parameters.  But those latter three functions aredeprecated and shouldn't be used.",}),"param":({"race this is the race of the character.  It should be arace that's understood by the /std/race.c","guild this is the guild, class, or profession of the NPC.","level this is the base skill level of the NPC.  Thenumber is used by the race object to set ability scores, andbase skills.",}),]),}),"set_throw_out":({({"void",}),({({"int",}),"hps",({"int",}),"chance",({"string",}),"their_mess",({"string",}),"everyone_mess",}),(["see":({"set_aggressive()","query_throw_out()","set_join_fights()","expand_string()",}),"main":({"This method is used to determine when to throw people out of aroom.  This is what detritus uses to throw people out of themended drum when it gets a bit rowdy.<p>The hps is the level of hps at which the npc will start throwingpeople out with the chance of it occuring (chance is a percentage).<p>People will be thrown into a random room, if the property<pre>\"no throw out\"</pre> is specified on the room then theywill not be thrown into that room.",}),"param":({"hps the number of hps at which to start throwing people out","chance the percentage chance of being thrown out","their_mess the message to show them","everyone_mess the message to show everyone else",}),]),}),"query_race":({({"string",}),({}),(["see":({"set_race()","query_guild()","set_level()",}),"main":({"This method returns the current race of the npc.",}),"return":({"the current race of the object",}),]),}),"query_follow_speed":({({"int",}),({}),(["see":({"set_follow_speed()",}),"main":({"This method queries the speed at which the npc will followafter a player when they leave combat.",}),"return":({"the current follow speed",}),]),}),"query_aggressive":({({"int",}),({}),(["see":({"set_aggressive()","start_attack()",}),"main":({"This method returns the current aggressive level of the npc.If the aggressive is set to 1, then the npc will attack all playersthat enter its environment.  If the aggressive is set to 2 thenthe npc will attack everything (including other npcs).<p>See the function start_attack() for information about things youcan do to stop aggressive npcs attacking things.",}),"return":({"the aggressive level of the npc",}),]),}),"add_language":({({"void",}),({({"string",}),"str",}),(["main":({"This method adds a language to the npc. <p>After the sun has died away<br>The stars come out and glow<br>Lighting the embers of good intentions<br>Ghostly white, unhappily bright<br>Time lost, the day done",}),"param":({"str the language to add",}),]),}),"rand_num":({({"int",}),({({"int",}),"no",({"int",}),"type",}),(["see":({"set_random_stats()",}),"main":({"This method generates a random number.  It used to setup the randomstats.",}),"return":({"the randomly generate number",}),"param":({"no the number of times to roll the dice","type the size of the dice",}),]),}),])
protected_functions (["got_the_route":({({"void",}),({({"string","*",}),"route",({"int",}),"delay",({"string",}),"dest",}),(["see":({"move_me_to()",}),"main":({"This method is called by the move_me_to function after theroute handler has successfuly discovered the route to follow.",}),"param":({"route the route to follow","delay the delay to follow it with","dest route destination",}),]),}),])
inherits (["/global/guild-race":({}),"/global/events":({}),"/std/living/mon_actions":({}),"/std/living/response_mon":({}),"/std/living/living":({}),])
main_docs (["author":({"Pinkfish",}),"main":({"This file contains all the information relevant to creating annpc (or monster).",}),])
define_docs (["SOUL_OBJECT":([]),])
includes (["/include/route.h":1059516193,"/include/playtesters.h":1059516192,"/include/skills.h":1059516192,"/include/move_failures.h":1059516192,"/include/top_ten_tables.h":1059516192,"/include/map.h":1059516192,"/include/combat.h":1059516193,"/include/player.h":1059516192,"/include/wander.h":1059516193,"/include/monster.h":1059516193,"/include/living.h":1059516192,"/include/config.h":1059515825,])
class_docs ([])
file_name "/obj/monster.c"
last_changed 1059781342
