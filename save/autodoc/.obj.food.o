#/obj/handlers/autodoc/autodoc_file.c
public_functions (["reset_liquid":({({"void",}),({}),(["see":({"set_liquid()","set_decay_speed()",}),"main":({"This changes the food object into a solid.  Solids are not'continuous' and the decay speed will be set back to thedefault.",}),]),}),"remove_external_effect":({({"void",}),({({"string",}),"word",}),(["see":({"add_external_effect()",}),"param":({"word The name of the effect to delete.",}),"main":({"This removes the external effect of the given name.",}),]),}),"query_decay_speed":({({"int",}),({}),(["see":({"set_decay_speed()",}),"return":({"The decay speed.",}),"main":({"This returns the decay speed.  If this is 0 then the objectis not decaying.  This is the length of time it takesfor the whole object to decay.",}),]),}),"set_piece_description":({({"void",}),({({"string",}),"word",}),(["see":({"query_in_pieces()","set_piece_short()","set_piece_plural()","set_piece_substance()",}),"example":({"set_piece_description(\"The brown, soft, moist cake looks \"  \"totally wonderful.\\n\");",}),"param":({"word The long description to use when cut into pieces.",}),"main":({"This sets the long description of the food when it is has'cut' into pieces.<p>If this is set then the short of the object is changedto 'piece of cake'.  If the piece description is notset the short description of the object is not changed.",}),]),}),"do_splash":({({"int",}),({({"object","*",}),"things",}),([]),}),"check_sharp":({({"int",}),({({"object",}),"weapon",}),(["return":({"Return 1 if it is sharp, or 0 otherwise.",}),"param":({"weapon The weapon to check to see if it is sharp.",}),"main":({"This checks to see if a weapon is sharp.  This is used laterto determine whather an object can be cut up with the weapon.",}),]),}),"set_in_pieces":({({"void",}),({({"int",}),"number",}),(["see":({"query_in_pieces()","set_piece_description()","set_piece_short()","set_piece_plural()","set_piece_substance()",}),"param":({"number The number of pieces.",}),"main":({"This sets the in_pieces flag.  This allows you to make thefood seem as though it has already been cut into pieces.",}),]),}),"query_eat_object":({({"string",}),({}),(["see":({"set_eat_object()","set_eat_func()","set_eat_mess()",}),"return":({"A string which is the the name of the eat object.",}),"main":({"This returns the eat object on which the eat functionof the food of the food is stored.",}),]),}),"query_external_effects":({({"mapping",}),({}),(["see":({"set_splashable(), set_applicable()",}),"return":({"A mapping containing the external effects.",}),"main":({"The external (splash,apply,rub) effects of the food.  Themapping contains a set of strings (the effect) and a numberassociated with the effect.",}),]),}),"add_eat_effect":({({"int",}),({({"mixed",}),"word",({"int",}),"number",}),(["see":({"/obj/cont_medium->set_weight_unit()","remove_eat_effect()",}),"return":({"The current value of the effect in the mapping",}),"param":({"word The file name of the effect to add.","number The number to set to the effect to.",}),"main":({"This adds an eat effect to the food.  This will be added tothe player or NPC when the food is eaten.<p>The effect is added with a number as the argument.  The numberis based on the amount which is eaten (in weight units), andusually represents the strength of the effect.If the object is continuous, the weight is calculated fromthe amount and weight_unit array...<p><br><code>eff_num = (amount * number * weight_unit[0]) / weight_unit[1]</code><p>...where the number is passed into the add_eat_effect() function.If the effect already exists, then the number is added ontothe existing number.",}),]),}),"do_dry":({({"int",}),({}),(["see":({"set_decay_speed()",}),"return":({"returns 1 for suceess and 0 for failure.",}),"main":({"This method dries the food.  Dried food no longer decays.",}),]),}),"set_eat_object":({({"void",}),({({"string",}),"word",}),(["see":({"set_eat_object()","set_eat_mess()",}),"example":({"void create_food() {  object food;  food = clone_object(\"/obj/food/apple.food\");  food->set_eat_object(this_object());  food->set_eat_func(\"eat_apple\");} /* create_food() */void eat_apple(object food, object eater) {  /* Do something wonderful! */} /* eat_rabbit() */",}),"param":({"word The object containing the eat function.",}),"main":({"This sets the object on which the eat function is stored.<p>If the eat object is set, then the eat function needs tobe set as well.  If the function is not set then settingthe object has no effect.<p>The function will be called with two parameters, the firstbeing the object being eaten and the second being theperson eating the object.",}),]),}),"set_eat_func":({({"void",}),({({"string",}),"word",}),(["see":({"set_eat_object()","set_eat_mess()",}),"example":({"See the example for set_eat_object()",}),"param":({"word The function to set as the eat function.",}),"main":({"This sets the eat function of the food.  This is called whenthe food is eaten.<p>If the eat object is set, then the eat function needs to beset as well. If the function is not set then setting theobject has no effect.<p>The function will be called with two parameters, the first being theobject being eaten and the second being the person eating the object.",}),]),}),"set_eat_mess":({({"void",}),({({"mixed",}),"word",}),(["see":({"set_eat_object()","set_eat_func()","/global/new_parse->add_succeeded_mess()",}),"param":({"word The string or array to be used asthe add_succeeded_mess() when eating the food.",}),"main":({"This sets the eat function of the food.  The function iscarried out when the food is consumed.  The eat message,set with set_eat_mess(), is displayed when this functionis carried out.<p>The eat mess should be treated exactly the same as aadd_succeeded_mess(), as it is processed later asadd_succeeded_mess(eat_mess, ({ }));",}),]),}),"query_dried":({({"int",}),({}),(["return":({"1 if it is dried, 0 if not",}),"main":({"This returns the dried state of the bit.",}),]),}),"set_splashable":({({"void",}),({}),(["see":({"unset_splashable(), set_applicable(), unset_applicable(),add_external_effect()",}),"main":({"This sets it so the food can be splashed.Note that the food can only be splashed when liquid in any case.Note this is NOT the default case.",}),]),}),"query_eat_mess":({({"string",}),({}),(["see":({"set_eat_object()","set_eat_func()","set_eat_mess()",}),"return":({"A string of text which is the eat message.",}),"main":({"This returns the eat message of the object.",}),]),}),"set_weight_per_bite":({({"void",}),({({"int",}),"number",}),(["see":({"/std/basic/misc->set_weight()","weight",}),"param":({"number The weight each bite should be.",}),"main":({"This sets weight of each bite of the food object.  This isused along with the total weight of the object to calculatehow many bites of the food can be taken.",}),]),}),"query_rotten":({({"int",}),({}),(["see":({"set_decay_speed()","query_decay_speed()","set_decay_level()","query_decay_level()","query_decay_divisor()",}),"return":({"Return 1 if the food has started to rot, 0 otherwise.",}),"main":({"This tells us if the food has started to rot",}),]),}),"query_long_decay_level":({({"string",}),({}),(["main":({"This method returns the decay level for the object as a string, it is used in the long() function.",}),]),}),"set_bites_gone":({({"void",}),({({"int",}),"number",}),(["see":({"set_weight_per_bite()",}),"param":({"number The number of bites gone.",}),"main":({"This sets the number of bites gone.  This helps determinethe total weight of the object.",}),]),}),"query_decay_divisor":({({"float",}),({}),(["see":({"set_decay_speed()","query_decay_speed()","set_decay_level()","query_decay_level()",}),"return":({"float the divisor",}),"main":({"This tells us the current divisor used to determine decay.  This can be modified with set_decay_speed.",}),]),}),"query_splashable":({({"int",}),({({"object",}),"splasher",({"object",}),"splashee",}),(["see":({"set_splashable(), unset_splashable(), set_liquid(),set_external_pk_check()",}),"return":({"1 if it can splash, 0 if it can't",}),"param":({"splasher - Who splashes.","splashee - Who is splashed.",}),"main":({"This queries splashability of the food.Note that the food can only be splashed when liquid and whenset_splashable() has been called",}),]),}),"query_edible":({({"int",}),({}),(["see":({"set_liquid()","query_liquid()",}),"return":({"Return 1 if the food is a liquid, and return 0 if it is not.",}),"main":({"This tells us if the food is edible (ie. can beconsumed using 'eat' instead of 'drink'.  If it isedible then it is not a liquid.",}),]),}),"set_eat_effects":({({"void",}),({({"mapping",}),"map",}),(["param":({"map The eat effects mapping.",}),"main":({"This sets all the eat effects.  This function should NOTbe used.  Please use add_eat_effect.",}),]),}),"do_eat":({({"varargs","int",}),({({"int",}),"no_mess",}),(["see":({"/global/new_parse->add_command()","/global/new_parse->add_succeeded_mess()","set_eat_mess()",}),"return":({"Return 1 on success, 2 on success + last bit eaten and return 0 on failure.",}),"param":({"no_mess don't use success messages",}),"main":({"This is the eat command call.  This is setup with add_command()and does the actual eating.",}),]),}),"do_cure":({({"int",}),({}),(["see":({"set_decay_speed()",}),"return":({"returns 1 for suceess and 0 for failure.",}),"main":({"This is called by the pickling stick.  It stops the foodobject decaying.",}),]),}),"query_liquid":({({"int",}),({}),(["return":({"Return 1 if the food is a liquid, and return 0 if it is not.",}),"main":({"This function returns one if the food is a liquid.",}),]),}),"do_drink":({({"int",}),({}),(["see":({"do_eat()","consume(*)","set_liquid()",}),"return":({"Return 1 if it succeeded, or return 0 if it failed.",}),"main":({"This gives the appropriate message for drinking things.",}),]),}),"query_eat_func":({({"string",}),({}),(["see":({"set_eat_object()","set_eat_func()","set_eat_mess()",}),"return":({"A string which is the name of the eat function.",}),"main":({"This returns the name of the eat function to carry outwhen the object is eaten.",}),]),}),"query_decay_level":({({"int",}),({}),(["see":({"set_decay_speed()",}),"return":({"The level of decay, which is between 1 and 6.",}),"main":({"This returns the level of the decay.  This will be a numberbetween 1 and 6.",}),]),}),"set_piece_substance":({({"void",}),({({"string",}),"substance",}),(["see":({"query_in_pieces()","set_piece_description()","set_piece_short()","set_piece_plural()",}),"example":({"set_piece_substance(\"goat cheese\");",}),"param":({"word The description of what the 'piece' is of.",}),"main":({"This sets a new description for what there are pieces of.For example, if you want the short of the food before itis cut up to be 'bar of chocolate', without the piecesubstance being set, when it is cut up it will become'a piece of bar of chocolate'.  If you set this in enablesyou to change that unwieldly description to 'a piece ofchocolate'.",}),]),}),"set_applicable":({({"void",}),({}),(["see":({"unset_applicable()",}),"main":({"This sets it so the food can be applied.Note this is the default case.",}),]),}),"unset_external_pk_check":({({"void",}),({}),(["see":({"add_external_effect(), set_applicable(), set_splashable()","set_external_pk_check()",}),"main":({"This makes the external effects not pk checked.",}),]),}),"remove_eat_effect":({({"void",}),({({"string",}),"word",}),(["see":({"add_eat_effect()",}),"param":({"word The name of the effect to delete.",}),"main":({"This removes the eat effect of the given name.",}),]),}),"query_applicable":({({"int",}),({({"object",}),"applier",({"object",}),"appliee",}),(["see":({"set_applicable(), unset_applicable(), set_external_pk_check()",}),"return":({"1 if it can be applied, 0 if it can't",}),"param":({"applier - Who applies it","appliee - Who it is applied to.",}),"main":({"This queries applicability of the food. (rubbing on someone)Note that the food can only be applied whenset_applicable() has been called",}),]),}),"unset_applicable":({({"void",}),({}),(["see":({"set_applicable()",}),"main":({"This sets it so the food cannot be applied.",}),]),}),"query_eat_effects":({({"mapping",}),({}),(["see":({"add_eat_effect()",}),"return":({"A mapping containing the eat effects.",}),"main":({"The eat effects of the food.  The mapping contains a set ofstrings (the effect) and a number associated with theeffect.",}),]),}),"consume":({({"varargs","void",}),({({"object",}),"consumer",({"int",}),"amount",({"string",}),"type",}),(["param":({"consumer The person doing the consumption.","amount The amount being consumed.","type Use \"splash\" or \"apply\" or \"external\" to use external effects, anything else for eat effects.",}),"main":({"This consumes some of the food.",}),]),}),"set_piece_short":({({"void",}),({({"string",}),"short",}),(["see":({"query_in_pieces()","set_piece_description()","set_piece_plural()","set_piece_substance()",}),"example":({"set_piece_short(\"slice\");",}),"param":({"word The short to use for the 'piece' when cut intopieces.",}),"main":({"This is the description used in the short for the pieces.When the object is cut up this is used as part of theshort description.  For example, it can change'piece of cake' to 'slice of cake', 'piece of chocolate'to 'square of chocolate', and so on.  If this the pieceshort has not been set it is set to the default which issimply \"piece\".",}),]),}),"unset_splashable":({({"void",}),({}),(["see":({"set_splashable()",}),"main":({"This sets it so the food cannot be splashed.Note that the food can only be splashed when liquid in any case.",}),]),}),"setup_eat_piece_messages":({({"void",}),({({"mixed",}),"piece",({"mixed",}),"amt",({"mixed",}),"last",}),(["param":({"piece the eat piece message. This can be either a string or anarray, it is passed to add_succeeded_mess().","amt the amount messages","last the message to print out when the last bit gets eaten",}),"main":({"This sets up the eat messages for pieces and stuff.  The amount messagewill replace the $amt$ string in the message with the amount_string().  ",}),]),}),"query_in_pieces":({({"int",}),({}),(["see":({"do_cut()",}),"return":({"Return 1 if it is in pieces, and return 0 otherwise.",}),"main":({"If the food has been cut up (using the 'cut' command)then this will return true.",}),]),}),"set_liquid":({({"void",}),({}),(["see":({"reset_liquid()","set_decay_speed()","/obj/cont_medium->set_continuous()",}),"main":({"This changes the food object into a liquid.  Liquids areautomatically a 'continuous' medium, which means it willcombine with other liquids of the same type.<p>This will automatically set the decay speed to 0.  Liquidsdo not decay.",}),]),}),"query_piece_description":({({"string",}),({}),(["see":({"set_piece_description()","query_in_pieces()",}),"return":({"A string of text which is the piece description.",}),"main":({"This returns the long description of the food object whenit is cut up into pieces.",}),]),}),"check_for_container":({({"int",}),({}),(["main":({"This checks the outside of us for a container and then destroys ourselvesif it is not a container.",}),]),}),"set_piece_plural":({({"void",}),({({"string",}),"plural",}),(["see":({"query_in_pieces()","set_piece_description()","set_piece_short()","set_piece_substance()",}),"example":({"set_piece_plural(\"slices\");",}),"param":({"word The plural used for the 'pieces' when cut intopieces.",}),"main":({"This plural description used for the pieces.  It is onlyreally of use if the piece short pluralises in an unusualmanner.  If it is not set the piece plural is set to whatthe pice short has been set to with an \"s\" stuck on theend, for example, slice to slices.",}),]),}),"setup_eat":({({"void",}),({({"string",}),"ob",({"string",}),"func",}),(["see":({"set_eat_object()","set_eat_func()",}),"param":({"ob The object to use.","func The function to use.",}),"main":({"This sets up the eat object and function.  This is used whenthe food is eaten.  The eat function is called on the eatobject.  If successful the eat message is added to the player.",}),]),}),"do_apply":({({"int",}),({({"object","*",}),"things",}),(["see":({"set_applicable()","consume(*)",}),"return":({"Return 1 if it succeeded, or return 0 if it failed.",}),"main":({"This handles applying things",}),]),}),"do_quaff":({({"int",}),({}),(["see":({"do_eat()","consume(*)","set_liquid()",}),"return":({"Return 1 if it succeeded, or return 0 if it failed.",}),"main":({"This gives the appropriate message for quaffing things. Itsrather like drinking but a lot of it gets splashed on you.",}),]),}),"query_short_rotten_adjective":({({"string",}),({}),(["return":({"a string like slightly rotten, mostly rotten, etc.",}),"main":({"This method returns the current rotten adjective that's used in the short description for decaying objects.",}),]),}),"query_food_object":({({"int",}),({}),(["return":({"1 when it is a food object",}),"main":({"This method returns 1 if the item is a food object.",}),]),}),"query_cured":({({"int",}),({}),(["return":({"1 if it is cured, 0 if not",}),"main":({"This returns the cured state of the bit.",}),]),}),"set_decay_level":({({"void",}),({({"int",}),"level",}),(["see":({"query_decay_level()","set_decay_speed()",}),"param":({"level The new decay level.",}),"main":({"This sets the decay level.  This should be anumberbetween 1 and 6.  It lets you make a food object seemas though it is already decaying.",}),]),}),"add_external_effect":({({"int",}),({({"string",}),"word",({"int",}),"number",}),(["see":({"/obj/cont_medium->set_weight_unit()","set_splashable()","unset_splashable()","set_applicable()","unset_applicable","remove_external_effect()","set_external_pk_check()",}),"return":({"The current value of the effect in the mapping",}),"param":({"word The file name of the effect to add.","number The number to set to the effect to.",}),"main":({"This adds an external effect to the food.  This will be added tothe player or NPC when the liquid is splashed, applied, or rubbed on them.<p>The effect is added with a number as the argument.  The numberis based on the amount which is splashed (in weight units), andusually represents the strength of the effect.If the object is continuous, the weight is calculated fromthe amount and weight_unit array...<p><br><code>eff_num = (amount * number * weight_unit[0]) / weight_unit[1]</code><p>...where the number is passed into the add_external_effect() function.If the effect already exists, then the number is added ontothe existing number.",}),]),}),"set_external_pk_check":({({"void",}),({}),(["see":({"add_external_effect(), set_applicable(), set_splashable()","unset_external_pk_check()",}),"main":({"This makes the external effects pk checked.",}),]),}),"do_cut":({({"varargs","int",}),({({"int",}),"num_pieces",}),(["see":({"set_piece_description()","query_in_pieces()","query_piece_short()","query_piece_plural()","query_piece_substance()",}),"return":({"1 if it succeeded, 0 if not.",}),"param":({"num_pieces The number of pieces to cut the food into.",}),"main":({"This cuts the food up into bits.  This is the command calledwith add_command() and does the actual cutting up into bits.  Ifthe num_pieces parameter is undefined, the food is cut in half.If the food is continuous, the cutting is handled bythe state_change handler (all continuous objects must be cut thisway).",}),]),}),"do_mince":({({"varargs","int",}),({}),([]),}),"set_external_effects":({({"void",}),({({"mapping",}),"map",}),(["param":({"map The external effects mapping.",}),"main":({"This sets all the external effects.  This function should NOTbe used.  Please use add_external_effect.",}),]),}),"query_weight_per_bite":({({"int",}),({}),(["see":({"/std/basic/misc->set_weight()","set_weight_per_bite()","weight",}),"return":({"The weight of each bite.",}),"main":({"This sets the weight of each bite of the food object.This is used along with the total weight of the objectto calculate how many bites of the food can be taken.",}),]),}),"query_long_eat_level":({({"string",}),({}),(["return":({"a string used in long().",}),"main":({"This method returns how much of the item has been nibbled on. ",}),]),}),"set_decay_speed":({({"void",}),({({"int",}),"decay",}),(["see":({"set_decay_level()","query_decay_speed()",}),"example":({"/* This will make the object decay totaly in 30 minutes */set_decay_speed(1800);/* This will stop the object from ever decsaying */set_decay_speed(0);",}),"param":({"speed The speed at which the object will decays.",}),"main":({"This sets the speed at which a food object decays.  Thespeed is set in seconds and is the total amount of timebefore the food decays.<p>If the decay speed is set to 0, then the object will never decay.",}),]),}),"query_bites_gone":({({"int",}),({}),(["see":({"set_bites_gone()","set_weight_per_bite()",}),"return":({"The number of bites which have been taken fromthe object.",}),"main":({"This returns the number of bites that have been taken outof the food object.",}),]),}),"query_decays":({({"int",}),({}),(["see":({"set_decay_speed()",}),"return":({"Return 1 if the object decays.",}),"main":({"This query tells us whether the food decays.  All objectswhich decay should have this function on them.",}),]),}),])
protected_functions ([])
inherits (["/std/basic/virtual_update":({}),"/obj/cont_medium":({}),])
main_docs (["main":({"<BR>This is the main inheritable for food objects.  It allows you tocreate food and drink.  Virtual files may also be coded if giventhe *.food extention.  There are many examples of these virtualfood files in the /obj/food directory.  Food does the followingthings.<BR><BR>  - It can be eaten or drunk.<BR>  - Food can be changed from solid to liquid with set_liquid(),and changed from liquid to solid with reset_liquid().<BR>  - The weight of each bite can be set with set_weight_per_bite().<BR>  - Effects can be added to the player when they are splashed with the food,get food rubbed on them, or get food applied to them withadd_external_effect.<BR>  - Splashing, applying, and rubbing can be pk-checked withset_external_pk_check()<BR>  - Splashing can be activated with set_splashable()<BR>  - Splashing can be deactivated with unset_splashable()<BR>  - Applying can be activated with set_applicable()<BR>  - Applying can be deactivated with unset_applicable()<BR>  - Effects can be added to the player when they consume the foodwith add_eat_effect().<BR>  - Functions can be added to be carried out when the food isconsumed with add_eat_func().  This function can be storedon another object if the set_eat_object() is used.<BR>  - An eat message can be set with set_eat_mess().<BR>  - Food can be cut up into pieces with sharp weapons.<BR>  - The description of the new 'pieces' can be set usingset_piece_description(), set_piece_short(), set_piece_plural(),and set_piece_substance().<BR>  - Non-liquid food decays and will eventually crumble to dust.<BR>  - The decay speed can be set with set_decay_speed().<BR>  - Food can be 'pickled' to prevent decay using do_cure().",}),])
define_docs (["STATE_CHANGE":([]),"DEFAULT_DECAY":([]),])
includes (["/include/move_failures.h":1059516192,"/include/bits_controller.h":1059516192,"/include/drinks.h":1059516193,"/include/playtesters.h":1059516192,"/include/weapon.h":1059516193,])
class_docs ([])
file_name "/obj/food.c"
last_changed 1059516270
